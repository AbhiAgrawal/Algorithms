class Solution:
    def __init__(self):
        self.memo = {}
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        
        if(len(startTime) == 1):
            return profit[0] 
        
        jobs = list(zip(startTime, endTime, profit))
        jobs.sort()
        (s, e, p) = zip(*jobs)

        return self.jobSchedulingMemo(s, e, p, 0, min(startTime))
    
    
    def jobSchedulingRecursiveNoMemo(self, startTime: List[int], endTime: List[int], profit: List[int], i: int, end: int) -> int:
        
        if(i == len(startTime)):
            return 0
        
        j = bisect_left(startTime, endTime[i], i+1, len(startTime))
        k = i+1
        return max(profit[i] + self.jobSchedulingRecursiveNoMemo(startTime, endTime, profit, j, endTime[i]),
                  self.jobSchedulingRecursiveNoMemo(startTime, endTime, profit, k, startTime[i]))
    
    def jobSchedulingMemo(self, startTime: List[int], endTime: List[int], profit: List[int], i: int, end: int) -> int:
        
        if(i == len(startTime)):
            return 0
        
        j = bisect_left(startTime, endTime[i], i+1, len(startTime))
        k = i+1
        if(j, endTime[i]) not in self.memo.keys():            
            self.memo[(j, endTime[i])] = self.jobSchedulingMemo(startTime, endTime, profit, j, endTime[i])
        if(k, startTime[i]) not in self.memo.keys():    
            self.memo[(k, startTime[i])] = self.jobSchedulingMemo(startTime, endTime, profit, k, startTime[i])
        return max(profit[i] + self.memo[(j, endTime[i])],
                  self.memo[(k, startTime[i])])
        
        
    
        
